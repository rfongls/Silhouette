#!/usr/bin/env python
"""
Ingest docs -> chunk -> embed (stub-friendly) -> synthesize a skill wrapper + example + test
and register it under skills/registry.yaml.

Usage:
  python scripts/ingest_skill.py --name textstat --docs docs_src/textstat.md --pattern "textstat.*" \
      --entry tool --desc "Text statistics helper"

Offline behavior:
  - Uses a stub embed (Jaccard on tokens) if sentence-transformers not available.
"""
import argparse
import json
import pathlib
import re

TEMPLATE_WRAPPER = """\
# Auto-generated by ingest_skill.py
import json
{imports}

def {entry}(text: str) -> str:
    \"\"\"{desc}\"\"\"
    {body}
"""

TEMPLATE_TEST = """\
# Auto-generated smoke test
def test_{name}_smoke():
    from {module} import {entry}
    out = {entry}({sample})
    assert isinstance(out, str) and len(out) > 0
"""

def _read_docs(path):
    return pathlib.Path(path).read_text(encoding="utf-8")

def _simple_chunks(text, sz=800):
    toks = text.split()
    for i in range(0, len(toks), sz):
        yield " ".join(toks[i:i+sz])

def _score_query(chunks, query):
    # stub "embedding": score by token overlap against query
    q = set(re.findall(r"[A-Za-z0-9_]+", query.lower()))
    scored = []
    for ch in chunks:
        s = set(re.findall(r"[A-Za-z0-9_]+", ch.lower()))
        j = len(q & s) / max(1, len(q | s))
        scored.append((j, ch))
    scored.sort(reverse=True, key=lambda x: x[0])
    return scored[:3]

def _synthesize_body(top_chunks):
    # Extremely simple synthesis heuristic; replace with LLM templating when available.
    # Provide a deterministic, safe "core" over docs hints.
    return "stats = {'length': len(text.split())}\n    return json.dumps(stats, separators=(',',':'))"

def _ensure_pkg(path):
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)
    init = pathlib.Path(path) / "__init__.py"
    if not init.exists():
        init.write_text("", encoding="utf-8")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--name", required=True)
    ap.add_argument("--docs", required=True, help="path to a markdown/txt docs file")
    ap.add_argument("--pattern", default="", help="focus regex to bias chunk selection")
    ap.add_argument("--entry", default="tool")
    ap.add_argument("--desc", default="Auto-generated skill")
    args = ap.parse_args()

    txt = _read_docs(args.docs)
    chunks = list(_simple_chunks(txt, 800))
    query = args.pattern or args.name
    top = _score_query(chunks, query)
    body = _synthesize_body([c for _, c in top])

    pkg_dir = pathlib.Path("skills") / args.name
    mod_path = pkg_dir / "wrapper.py"
    _ensure_pkg(pkg_dir)
    wrapper = TEMPLATE_WRAPPER.format(imports="",
                                      entry=args.entry,
                                      desc=args.desc,
                                      body=body)
    mod_path.write_text(wrapper, encoding="utf-8")

    # test
    test_dir = pathlib.Path("skills") / args.name / "tests"
    _ensure_pkg(test_dir)
    sample = json.dumps("hello world")
    test_code = TEMPLATE_TEST.format(name=args.name,
                                     module=f"skills.{args.name}.wrapper",
                                     entry=args.entry,
                                     sample=sample)
    (test_dir / f"test_{args.name}_smoke.py").write_text(test_code, encoding="utf-8")

    # registry append (idempotent best-effort)
    regp = pathlib.Path("skills/registry.yaml")
    reg = {"skills": []}
    if regp.exists():
        import yaml
        reg = yaml.safe_load(regp.read_text(encoding="utf-8")) or {"skills": []}
    found = False
    for s in reg["skills"]:
        if s.get("name") == args.name:
            s.update({"module": f"skills.{args.name}.wrapper", "entry": args.entry, "enabled": True, "description": args.desc})
            found = True
            break
    if not found:
        reg["skills"].append({"name": args.name, "module": f"skills.{args.name}.wrapper", "entry": args.entry, "enabled": True, "description": args.desc})
    import yaml
    regp.write_text(yaml.safe_dump(reg, sort_keys=False), encoding="utf-8")

    print(f"Created skill '{args.name}' at {mod_path} and updated registry.")

if __name__ == "__main__":
    main()
