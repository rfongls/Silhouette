{% extends "layout.html" %}
{% block content %}
{% set req = request if request is defined else none %}
{% set root = req.scope.get('root_path', '') if req else '' %}
<section class="dashboard">
  <div class="dashboard-container">
    <!-- Toasts and lightweight styles for Phase 2B additions -->
    <style>
      .toasts { position: fixed; top: 1rem; right: 1rem; z-index: 9999; display: flex; flex-direction: column; gap: .5rem; }
      .toast { background: #222; color: #fff; padding: .5rem .75rem; border-radius: .375rem; box-shadow: 0 2px 8px rgba(0, 0, 0, .2); opacity: .95; display: flex; align-items: center; gap: .5rem; }
      .toast.success { background: #1b7f4d; }
      .toast.error { background: #9b1c1c; }
      .toast.info { background: #1e40af; }
      .toast .x { background: transparent; border: none; color: inherit; cursor: pointer; padding: 0 .25rem; }
      pre.diff { background: #0a0a0a; color: #ddd; padding: .75rem; border-radius: .375rem; overflow: auto; max-height: 22rem; }
      .diff-line { white-space: pre-wrap; }
      .diff-line.add { background: rgba(16, 185, 129, .12); }
      .diff-line.rem { background: rgba(239, 68, 68, .14); }
      .diff-line.neu { opacity: .85; }
      .status-chip { display:inline-block; padding:.125rem .375rem; border-radius:.375rem; font-size:.8rem; text-transform:uppercase; letter-spacing:.02em; }
      .st-queued { background:#2a2a2a; color:#f3f4f6; }
      .st-leased { background:#1e40af; color:#f8fafc; }
      .st-running { background:#0d9488; color:#ecfeff; }
      .st-succeeded { background:#1b7f4d; color:#ecfdf5; }
      .st-dead, .st-canceled { background:#9b1c1c; color:#fee2e2; }
      .st-failed { background:#b45309; color:#fffbeb; }
      .chart-wrap { width: 100%; overflow: auto; }
    </style>
    <div id="toast-root" class="toasts" aria-live="polite" aria-atomic="true"></div>

    <header class="dashboard-header">
      <h1 class="text-h1">Engine (Beta)</h1>
      <p class="text-body">Preview the new runtime for adapters, operators, routers, and sinks.</p>
    </header>

    <section class="card mb">
      <h2 class="text-h2">Pipelines</h2>
      <div class="row small" style="gap:.5rem; align-items:center; margin-bottom:.5rem">
        <button class="btn btn-primary btn-sm" id="pl-new-btn">New pipeline</button>
        <span class="text-body muted" id="pl-status"></span>
      </div>
      <div class="table-wrapper">
        <table class="table" id="pl-table">
          <thead>
            <tr>
              <th style="width:36%">Name</th>
              <th>Description</th>
              <th style="width:18%">Updated</th>
              <th style="width:32%">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="4">Loading…</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <section class="card mb" id="pl-editor" style="display:none">
      <h2 class="text-h2">Pipeline editor</h2>
      <div class="row small" style="gap:1rem; margin-bottom:.5rem">
        <input class="input" id="pl-name" placeholder="Name" style="min-width:18rem">
        <input class="input" id="pl-desc" placeholder="Description" style="min-width:24rem">
        <button class="btn btn-text btn-sm" id="pl-sync-btn" title="Sync name into YAML">Sync name → YAML</button>
        <button class="btn btn-text btn-sm" id="pl-diff-btn" title="Show YAML diff">Diff</button>
      </div>
      <textarea id="pl-yaml" class="input" style="width:100%; height:18rem; font-family: ui-monospace, Menlo, monospace;"></textarea>
      <div class="row small" style="gap:.5rem; margin-top:.5rem">
        <button class="btn btn-secondary btn-sm" id="pl-validate-btn">Validate</button>
        <button class="btn btn-primary btn-sm" id="pl-save-btn">Save</button>
        <button class="btn btn-text btn-sm" id="pl-cancel-btn">Cancel</button>
        <span class="text-body muted" id="pl-editor-status"></span>
      </div>
    </section>

    <section class="card mb" id="pl-diff-card" style="display:none">
      <h2 class="text-h2">YAML diff</h2>
      <p class="text-body muted">Lines removed in red, added in green. Shows differences between the last loaded/saved version and current edits.</p>
      <pre id="pl-diff" class="diff"></pre>
    </section>

    <!-- Jobs -->
    <section class="card mb" id="jobs-card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2 class="text-h2">Jobs</h2>
        <div class="row small" style="gap:.5rem">
          <button class="btn btn-secondary btn-sm" id="jobs-refresh">Refresh</button>
        </div>
      </div>
      <div class="table-wrapper">
        <table class="table" id="jobs-table">
          <thead>
            <tr>
              <th style="width:7%">ID</th>
              <th style="width:20%">Pipeline</th>
              <th style="width:10%">Kind</th>
              <th style="width:12%">Status</th>
              <th style="width:8%">Attempts</th>
              <th style="width:15%">Scheduled</th>
              <th>Last error</th>
              <th style="width:16%">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="8">No jobs.</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Endpoints -->
    <section class="card mb" id="endpoints-card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2 class="text-h2">Endpoints</h2>
        <div class="row small" style="gap:.5rem">
          <button class="btn btn-secondary btn-sm" id="endpoints-refresh">Refresh</button>
        </div>
      </div>
      <div class="row small" style="gap:1.5rem; flex-wrap:wrap; margin-bottom:.75rem">
        <div style="flex:1; min-width:20rem">
          <h3 class="text-h3">Inbound listener</h3>
          <div class="row small" style="gap:.5rem; flex-wrap:wrap">
            <input id="endpoint-in-name" class="input" placeholder="Name" style="flex:1; min-width:10rem">
            <input id="endpoint-in-host" class="input" placeholder="Host/IP" style="flex:1; min-width:9rem">
            <input id="endpoint-in-port" class="input" type="number" min="1" max="65535" placeholder="Port" style="width:6rem">
          </div>
          <div class="row small" style="gap:.5rem; flex-wrap:wrap; margin-top:.5rem">
            <select id="endpoint-in-pipeline" class="input" style="flex:1; min-width:12rem">
              <option value="">Select pipeline…</option>
            </select>
            <input id="endpoint-in-cidrs" class="input" placeholder="Allow CIDRs (comma or newline)" style="flex:1; min-width:12rem">
          </div>
          <div class="row small" style="gap:.5rem; margin-top:.5rem">
            <button class="btn btn-primary btn-sm" id="endpoint-create-in">Create inbound</button>
          </div>
        </div>
        <div style="flex:1; min-width:18rem">
          <h3 class="text-h3">Outbound target</h3>
          <div class="row small" style="gap:.5rem; flex-wrap:wrap">
            <input id="endpoint-out-name" class="input" placeholder="Name" style="flex:1; min-width:10rem">
            <input id="endpoint-out-host" class="input" placeholder="Host/IP" style="flex:1; min-width:9rem">
            <input id="endpoint-out-port" class="input" type="number" min="1" max="65535" placeholder="Port" style="width:6rem">
          </div>
          <div class="row small" style="gap:.5rem; margin-top:.5rem">
            <button class="btn btn-primary btn-sm" id="endpoint-create-out">Create outbound</button>
          </div>
        </div>
        <div style="flex:1; min-width:22rem">
          <h3 class="text-h3">Send test message</h3>
          <div class="row small" style="gap:.5rem; flex-wrap:wrap">
            <select id="endpoint-send-target" class="input" style="flex:1; min-width:10rem">
              <option value="">-- choose target --</option>
            </select>
            <input id="endpoint-send-host" class="input" placeholder="Host/IP" style="flex:1; min-width:9rem">
            <input id="endpoint-send-port" class="input" type="number" min="1" max="65535" placeholder="Port" style="width:6rem">
          </div>
          <textarea id="endpoint-send-message" class="input" style="width:100%; height:6rem; margin-top:.5rem" placeholder="Paste HL7 message…"></textarea>
          <div class="row small" style="gap:.5rem; margin-top:.5rem">
            <button class="btn btn-secondary btn-sm" id="endpoint-send-btn">Send</button>
          </div>
        </div>
      </div>
      <div class="table-wrapper">
        <table class="table" id="endpoints-table">
          <thead>
            <tr>
              <th>Name</th>
              <th>Kind</th>
              <th>Bind/Target</th>
              <th>Pipeline</th>
              <th>Status</th>
              <th>Notes</th>
              <th style="width:20%">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="7">No endpoints.</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Assist -->
    <section class="card mb" id="assist-card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2 class="text-h2">Assist (Phase 4)</h2>
        <div class="row small" style="gap:.5rem">
          <label class="text-body muted" for="assist-lookback">Lookback days</label>
          <input id="assist-lookback" class="input" type="number" min="1" max="90" value="14" style="width:5rem">
          <button class="btn btn-secondary btn-sm" id="assist-preview">Get suggestions</button>
          <button class="btn btn-primary btn-sm" id="assist-insert">Insert draft into YAML</button>
        </div>
      </div>
      <div class="row small" style="gap:1rem; flex-wrap:wrap">
        <div style="flex:1; min-width:20rem">
          <h3 class="text-h3">Allowlist</h3>
          <pre id="assist-allowlist" class="diff" style="min-height:6rem">—</pre>
        </div>
        <div style="flex:1; min-width:20rem">
          <h3 class="text-h3">Severity rules</h3>
          <pre id="assist-severity" class="diff" style="min-height:6rem">—</pre>
        </div>
      </div>
      <div class="row small" style="gap:.5rem">
        <h3 class="text-h3">Draft YAML (commented)</h3>
      </div>
      <pre id="assist-draft" class="diff" style="min-height:8rem">—</pre>
      <div class="row small" style="gap:.5rem; align-items:center; margin-top:.5rem">
        <label class="text-body muted" for="assist-recent">Anomalies</label>
        <input id="assist-recent" class="input" type="number" min="1" max="60" value="7" style="width:4rem">
        <input id="assist-baseline" class="input" type="number" min="7" max="120" value="30" style="width:4rem">
        <button class="btn btn-secondary btn-sm" id="assist-load-anoms">Load anomalies</button>
      </div>
      <div class="table-wrapper">
        <table class="table" id="assist-anoms-table">
          <thead>
            <tr><th>Code</th><th>Segment</th><th>Count</th><th>Baseline/day</th><th>|z|</th><th>Window</th></tr>
          </thead>
          <tbody><tr><td colspan="6">—</td></tr></tbody>
        </table>
      </div>
    </section>

    <section class="card">
      <h2 class="text-h2">Insights</h2>
      <p class="text-body muted">Seed the store then review run-level summaries below.</p>
      <div class="chart-wrap mb">
        <canvas id="insights-chart" width="960" height="260" aria-label="Recent run issues chart"></canvas>
      </div>
      <div class="insights-summary" id="insights-summary">
        <div class="row small">
          <div class="badge muted" id="insights-totals">Loading…</div>
        </div>
        <div class="table-wrapper">
          <table class="table" id="insights-table">
            <thead>
              <tr>
                <th>Run</th>
                <th>Messages</th>
                <th>Errors</th>
                <th>Warnings</th>
                <th>Passed</th>
                <th>Started</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6">Loading…</td></tr>
            </tbody>
          </table>
        </div>
        <div class="mt" id="insights-rules"></div>
      </div>
    </section>
  </div>
</section>
<script>
  async function loadInsightsSummary() {
    const root = ROOT_PATH;
    const target = document.getElementById('insights-table')?.querySelector('tbody');
    const badge = document.getElementById('insights-totals');
    const rules = document.getElementById('insights-rules');
    if (!target || !badge || !rules) return;
    target.innerHTML = '<tr><td colspan="6">Loading…</td></tr>';
    try {
      const response = await fetch(root + '/api/insights/summary');
      if (!response.ok) {
        throw new Error('Request failed');
      }
      const summary = await response.json();
      badge.textContent = `Runs: ${summary.totals.runs} • Messages: ${summary.totals.messages} • Issues: ${summary.totals.issues}`;
      const rows = summary.by_run.map((run) => (
        `<tr>
          <td><span class="badge mono">#${run.run_id}</span> ${escapeHtml(run.pipeline)}</td>
          <td>${run.messages}</td>
          <td>${run.issues.error}</td>
          <td>${run.issues.warning}</td>
          <td>${run.issues.passed}</td>
          <td>${run.started_at}</td>
        </tr>`
      )).join('');
      target.innerHTML = rows || '<tr><td colspan="6">No runs recorded. Execute the seed script to populate demo data.</td></tr>';
      if (summary.by_rule.length) {
        const ruleList = summary.by_rule.slice(0, 6).map((item) => (
          `<span class="badge">${escapeHtml(item.code)} (${escapeHtml(item.severity)} · ${item.count})</span>`
        )).join(' ');
        rules.innerHTML = `<div class="row wrap small"><strong>Top findings:</strong> ${ruleList}</div>`;
      } else {
        rules.textContent = 'No findings yet. Operators will populate issues when pipelines run.';
      }
      try { renderInsightsChart(summary); } catch (err) { console.warn('Failed to render chart', err); }
    } catch (err) {
      console.error('Failed to load insights summary', err);
      badge.textContent = 'Unable to load insights summary. Ensure the API is running.';
      target.innerHTML = '<tr><td colspan="6">Summary unavailable.</td></tr>';
    }
  }

  const PLS = { currentId: null, origYaml: '', pipelines: [] };
  const ENDPOINTS = { items: [] };
  const TEMPLATE_ROOT = "{{ root }}";
  const ROOT_PATH = (document.body?.dataset?.root ?? TEMPLATE_ROOT) || '';

  function currentPipelineId() {
    if (PLS.currentId) return PLS.currentId;
    const button = document.querySelector('#pl-table tbody tr button[data-pipeline]');
    if (button instanceof HTMLButtonElement) {
      const id = Number(button.dataset.pipeline);
      if (!Number.isNaN(id)) return id;
    }
    return null;
  }

  function renderEndpointPipelineOptions() {
    const select = document.getElementById('endpoint-in-pipeline');
    if (!(select instanceof HTMLSelectElement)) return;
    const previous = select.value;
    const options = ['<option value="">Select pipeline…</option>'];
    for (const item of PLS.pipelines || []) {
      options.push(`<option value="${item.id}">${escapeHtml(item.name || `Pipeline #${item.id}`)}</option>`);
    }
    select.innerHTML = options.join('');
    if (previous && options.some((opt) => opt.includes(`value="${previous}"`))) {
      select.value = previous;
    }
  }

  async function withBusy(button, fn) {
    if (!button) return fn();
    if (button.dataset.busy === '1') return undefined;
    button.dataset.busy = '1';
    const wasDisabled = button.disabled;
    button.disabled = true;
    try {
      return await fn();
    } finally {
      button.dataset.busy = '0';
      button.disabled = wasDisabled;
    }
  }

  function showToast(kind, message, timeoutMs = 2600) {
    const root = document.getElementById('toast-root');
    if (!root) return;
    const el = document.createElement('div');
    el.className = `toast ${kind}`;
    el.innerHTML = `<span>${escapeHtml(message || '')}</span><button class="x" aria-label="Close">✕</button>`;
    root.appendChild(el);
    const close = () => {
      if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    };
    el.querySelector('.x')?.addEventListener('click', close);
    setTimeout(close, timeoutMs);
  }

  function escapeHtml(value) {
    const span = document.createElement('span');
    span.textContent = value ?? '';
    return span.innerHTML;
  }

  function encodeBase64(text) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(text || '');
    let binary = '';
    bytes.forEach((byte) => {
      binary += String.fromCharCode(byte);
    });
    return btoa(binary);
  }

  function setPipelineStatus(message) {
    const target = document.getElementById('pl-status');
    if (target) target.textContent = message || '';
  }

  function setEditorStatus(message) {
    const target = document.getElementById('pl-editor-status');
    if (target) target.textContent = message || '';
  }

  async function extractError(response) {
    const text = await response.text();
    try {
      const data = JSON.parse(text);
      const detail = data?.detail;
      if (typeof detail === 'string') {
        return detail;
      }
      if (Array.isArray(detail) && detail.length) {
        const first = detail[0];
        if (first && typeof first.msg === 'string') return first.msg;
        return JSON.stringify(detail);
      }
      if (detail && typeof detail === 'object' && typeof detail.msg === 'string') {
        return detail.msg;
      }
    } catch (err) {
      // ignore JSON parse failures; fall back to raw text
    }
    return text || response.statusText || 'Request failed';
  }

  function syncYamlName(yamlText, nameValue) {
    const name = (nameValue || '').trim();
    if (!name) return yamlText;
    const lines = (yamlText || '').split(/\r?\n/);
    let changed = false;
    for (let i = 0; i < lines.length; i += 1) {
      if (/^\s*name\s*:/.test(lines[i])) {
        lines[i] = `name: ${name}`;
        changed = true;
        break;
      }
    }
    if (!changed) {
      let inserted = false;
      for (let i = 0; i < lines.length; i += 1) {
        if (/^\s*version\s*:/.test(lines[i])) {
          lines.splice(i + 1, 0, `name: ${name}`);
          inserted = true;
          break;
        }
      }
      if (!inserted) {
        lines.unshift(`name: ${name}`);
      }
    }
    return lines.join('\n');
  }

  function diffLines(a, b) {
    const A = a.split(/\r?\n/);
    const B = b.split(/\r?\n/);
    const m = A.length;
    const n = B.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 1; i <= m; i += 1) {
      for (let j = 1; j <= n; j += 1) {
        if (A[i - 1] === B[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
        }
      }
    }
    const out = [];
    let i = m;
    let j = n;
    while (i > 0 || j > 0) {
      if (i > 0 && j > 0 && A[i - 1] === B[j - 1]) {
        out.push([' ', A[i - 1]]);
        i -= 1;
        j -= 1;
      } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
        out.push(['+', B[j - 1]]);
        j -= 1;
      } else {
        out.push(['-', A[i - 1]]);
        i -= 1;
      }
    }
    return out.reverse();
  }

  function renderYamlDiff() {
    const before = PLS.origYaml || '';
    const after = document.getElementById('pl-yaml').value || '';
    const beforeLines = before.split(/\r?\n/);
    const afterLines = after.split(/\r?\n/);
    const card = document.getElementById('pl-diff-card');
    const pre = document.getElementById('pl-diff');
    if ((beforeLines.length * afterLines.length) > 200000) {
      if (pre) {
        pre.innerHTML = '<span class="muted">Diff too large to render.</span>';
      }
      if (card) {
        card.style.display = '';
      }
      return;
    }
    const lines = diffLines(before, after);
    const html = lines.map(([tag, line]) => {
      const esc = escapeHtml(line);
      if (tag === '+') return `<div class="diff-line add">+ ${esc}</div>`;
      if (tag === '-') return `<div class="diff-line rem">- ${esc}</div>`;
      return `<div class="diff-line neu">  ${esc}</div>`;
    }).join('');
    if (pre) {
      pre.innerHTML = html || '<span class="muted">No differences.</span>';
    }
    if (card) {
      card.style.display = '';
    }
  }

  async function loadPipelines() {
    const root = ROOT_PATH;
    const tbody = document.querySelector('#pl-table tbody');
    if (!tbody) return;
    tbody.innerHTML = '<tr><td colspan="4">Loading…</td></tr>';
    try {
      const response = await fetch(root + '/api/engine/pipelines');
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      const data = await response.json();
      PLS.pipelines = Array.isArray(data.items) ? data.items : [];
      renderEndpointPipelineOptions();
      const rows = PLS.pipelines.map((item) => `
        <tr>
          <td><strong>${escapeHtml(item.name)}</strong></td>
          <td class="muted">${escapeHtml(item.description || '')}</td>
          <td class="mono">${escapeHtml(item.updated_at || '')}</td>
          <td>
            <button class="btn btn-secondary btn-xs" data-pipeline="${item.id}" data-action="run-dry">Run (dry)</button>
            <button class="btn btn-primary btn-xs" data-pipeline="${item.id}" data-action="run-persist">Run (persist)</button>
            <button class="btn btn-info btn-xs" data-pipeline="${item.id}" data-action="run-bg">Run in background</button>
            <button class="btn btn-text btn-xs" data-pipeline="${item.id}" data-action="edit">Edit</button>
            <button class="btn btn-text btn-xs" data-pipeline="${item.id}" data-action="delete">Delete</button>
          </td>
        </tr>
      `).join('');
      tbody.innerHTML = rows || '<tr><td colspan="4">No pipelines yet. Click "New pipeline" to create one.</td></tr>';
      refreshEndpoints();
    } catch (err) {
      console.error(err);
      tbody.innerHTML = '<tr><td colspan="4">Failed to load pipelines.</td></tr>';
      setPipelineStatus('Unable to load pipelines.');
    }
  }

  function statusChip(status) {
    const key = String(status || '').toLowerCase();
    const cls = {
      queued: 'st-queued',
      leased: 'st-leased',
      running: 'st-running',
      succeeded: 'st-succeeded',
      canceled: 'st-canceled',
      dead: 'st-dead',
      failed: 'st-failed',
    }[key] || 'st-queued';
    return `<span class="status-chip ${cls}">${escapeHtml(status || '')}</span>`;
  }

  async function enqueueBackgroundRun(pipelineId) {
    const root = ROOT_PATH;
    const body = {
      pipeline_id: pipelineId,
      kind: 'run',
      payload: { persist: true },
    };
    const response = await fetch(`${root}/api/engine/jobs`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Failed to enqueue: ${detail}`);
      return;
    }
    showToast('success', 'Enqueued background job');
    await refreshJobs();
  }

  async function cancelJob(jobId) {
    const root = ROOT_PATH;
    const response = await fetch(`${root}/api/engine/jobs/${jobId}/cancel`, { method: 'POST' });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Cancel failed: ${detail}`);
      return;
    }
    await refreshJobs();
  }

  async function retryJob(jobId) {
    const root = ROOT_PATH;
    const response = await fetch(`${root}/api/engine/jobs/${jobId}/retry`, { method: 'POST' });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Retry failed: ${detail}`);
      return;
    }
    await refreshJobs();
  }

  async function refreshJobs() {
    const root = ROOT_PATH;
    const tbody = document.querySelector('#jobs-table tbody');
    if (!tbody) return;
    tbody.innerHTML = '<tr><td colspan="8">Loading…</td></tr>';
    try {
      const response = await fetch(`${root}/api/engine/jobs?limit=50`);
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      const data = await response.json();
      const items = data.items || [];
      const rows = items.map((job) => {
        const err = job.last_error ? String(job.last_error) : '';
        const truncated = err.length > 90 ? `${escapeHtml(err.slice(0, 90))}…` : escapeHtml(err);
        const scheduled = job.scheduled_at ? new Date(job.scheduled_at).toLocaleString() : '';
        let actionHtml = '';
        if ([ 'queued', 'leased', 'running' ].includes(job.status)) {
          actionHtml = `<button class="btn btn-danger btn-xs" data-job-action="cancel" data-job-id="${job.id}">Cancel</button>`;
        } else if ([ 'dead', 'canceled', 'failed' ].includes(job.status)) {
          actionHtml = `<button class="btn btn-secondary btn-xs" data-job-action="retry" data-job-id="${job.id}">Retry</button>`;
        }
        return `
          <tr>
            <td>${job.id}</td>
            <td>#${job.pipeline_id}</td>
            <td>${escapeHtml(job.kind)}</td>
            <td>${statusChip(job.status)}</td>
            <td>${job.attempts}/${job.max_attempts}</td>
            <td>${escapeHtml(scheduled)}</td>
            <td title="${escapeHtml(err)}">${truncated || '&nbsp;'}</td>
            <td>${actionHtml || ''}</td>
          </tr>
        `;
      }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="8">No jobs.</td></tr>';
    } catch (err) {
      console.error(err);
      tbody.innerHTML = '<tr><td colspan="8">Failed to load jobs.</td></tr>';
      showToast('error', `Failed to load jobs: ${err.message || err}`);
    }
  }

  function handleJobAction(event) {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;
    const jobId = Number(target.dataset.jobId);
    if (!jobId) return;
    const action = target.dataset.jobAction;
    if (action === 'cancel') {
      withBusy(target, () => cancelJob(jobId));
    } else if (action === 'retry') {
      withBusy(target, () => retryJob(jobId));
    }
  }

  function renderEndpointTargets() {
    const select = document.getElementById('endpoint-send-target');
    if (!(select instanceof HTMLSelectElement)) return;
    const prior = select.value;
    const options = ['<option value="">-- choose target --</option>'];
    for (const endpoint of ENDPOINTS.items || []) {
      if (endpoint.kind === 'mllp_out') {
        options.push(`<option value="${endpoint.name}">${escapeHtml(endpoint.name)} (${escapeHtml(endpoint.config?.host || '')}:${escapeHtml(String(endpoint.config?.port ?? ''))})</option>`);
      }
    }
    select.innerHTML = options.join('');
    if (prior && options.some((opt) => opt.includes(`value="${prior}"`))) {
      select.value = prior;
    }
  }

  async function refreshEndpoints() {
    const tbody = document.querySelector('#endpoints-table tbody');
    if (!tbody) return;
    tbody.innerHTML = '<tr><td colspan="7">Loading…</td></tr>';
    try {
      const response = await fetch(`${ROOT_PATH}/api/engine/endpoints`);
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      const data = await response.json();
      ENDPOINTS.items = Array.isArray(data.items) ? data.items : [];
      renderEndpointTargets();
      const rows = ENDPOINTS.items.map((endpoint) => {
        const cfg = endpoint.config || {};
        const host = cfg.host ? `${cfg.host}:${cfg.port ?? ''}` : '';
        const pipelineRecord = (PLS.pipelines || []).find((p) => p.id === endpoint.pipeline_id);
        const pipeline = pipelineRecord
          ? `${pipelineRecord.name || `Pipeline #${endpoint.pipeline_id}`} (#${endpoint.pipeline_id})`
          : (endpoint.pipeline_id ? `#${endpoint.pipeline_id}` : '');
        const allow = Array.isArray(cfg.allow_cidrs) ? cfg.allow_cidrs.join(', ') : '';
        const actions = [];
        if (endpoint.kind === 'mllp_in') {
          actions.push(`<button class="btn btn-secondary btn-xs" data-endpoint="${endpoint.id}" data-endpoint-action="start">Start</button>`);
          actions.push(`<button class="btn btn-text btn-xs" data-endpoint="${endpoint.id}" data-endpoint-action="stop">Stop</button>`);
        }
        actions.push(`<button class="btn btn-text btn-xs" data-endpoint="${endpoint.id}" data-endpoint-action="delete">Delete</button>`);
        const notes = endpoint.kind === 'mllp_in'
          ? (allow ? `Allow: ${escapeHtml(allow)}` : 'Allowlist required')
          : '';
        return `
          <tr>
            <td>${escapeHtml(endpoint.name)}</td>
            <td>${escapeHtml(endpoint.kind)}</td>
            <td>${escapeHtml(host)}</td>
            <td>${escapeHtml(pipeline)}</td>
            <td>${escapeHtml(endpoint.status || '')}</td>
            <td>${notes || '&nbsp;'}</td>
            <td>${actions.join(' ')}</td>
          </tr>
        `;
      }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="7">No endpoints.</td></tr>';
    } catch (err) {
      console.error(err);
      tbody.innerHTML = '<tr><td colspan="7">Failed to load endpoints.</td></tr>';
      showToast('error', `Failed to load endpoints: ${err.message || err}`);
    }
  }

  function handleEndpointAction(event) {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;
    const endpointId = Number(target.dataset.endpoint);
    if (!endpointId) return;
    const action = target.dataset.endpointAction;
    if (!action) return;
    if (action === 'start') {
      withBusy(target, () => modifyEndpoint(endpointId, 'start'));
    } else if (action === 'stop') {
      withBusy(target, () => modifyEndpoint(endpointId, 'stop'));
    } else if (action === 'delete') {
      if (!confirm('Delete this endpoint?')) return;
      withBusy(target, () => deleteEndpoint(endpointId));
    }
  }

  async function modifyEndpoint(endpointId, action) {
    const response = await fetch(`${ROOT_PATH}/api/engine/endpoints/${endpointId}/${action}`, { method: 'POST' });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `${action} failed: ${detail}`);
      return;
    }
    await refreshEndpoints();
    const verb = action === 'start' ? 'started' : action === 'stop' ? 'stopped' : action;
    showToast('success', `Endpoint ${verb}`);
  }

  async function deleteEndpoint(endpointId) {
    const response = await fetch(`${ROOT_PATH}/api/engine/endpoints/${endpointId}`, { method: 'DELETE' });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Delete failed: ${detail}`);
      return;
    }
    await refreshEndpoints();
    showToast('success', 'Endpoint deleted');
  }

  async function createInboundEndpoint() {
    const nameEl = document.getElementById('endpoint-in-name');
    const hostEl = document.getElementById('endpoint-in-host');
    const portEl = document.getElementById('endpoint-in-port');
    const pipelineSelect = document.getElementById('endpoint-in-pipeline');
    const cidrsEl = document.getElementById('endpoint-in-cidrs');
    if (
      !(nameEl instanceof HTMLInputElement) ||
      !(hostEl instanceof HTMLInputElement) ||
      !(portEl instanceof HTMLInputElement) ||
      !(cidrsEl instanceof HTMLInputElement)
    ) {
      showToast('error', 'Inbound form not ready');
      return;
    }
    const pipelineId = pipelineSelect instanceof HTMLSelectElement ? Number(pipelineSelect.value) : 0;
    const name = nameEl.value.trim();
    const host = hostEl.value.trim();
    const portValue = portEl.value;
    const cidrsRaw = cidrsEl.value;
    if (!name || !host || !portValue || !pipelineId) {
      showToast('error', 'Name, host, port, and pipeline are required');
      return;
    }
    const allowCidrs = (cidrsRaw || '')
      .split(/[,\n\r]+/)
      .map((item) => item.trim())
      .filter(Boolean);
    const body = {
      kind: 'mllp_in',
      name,
      pipeline_id: pipelineId,
      config: { host, port: Number(portValue), allow_cidrs: allowCidrs },
    };
    const response = await fetch(`${ROOT_PATH}/api/engine/endpoints`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Create failed: ${detail}`);
      return;
    }
    showToast('success', 'Inbound endpoint created');
    nameEl.value = '';
    hostEl.value = '';
    portEl.value = '';
    cidrsEl.value = '';
    if (pipelineSelect instanceof HTMLSelectElement) {
      pipelineSelect.value = '';
    }
    await refreshEndpoints();
  }

  async function createOutboundEndpoint() {
    const nameEl = document.getElementById('endpoint-out-name');
    const hostEl = document.getElementById('endpoint-out-host');
    const portEl = document.getElementById('endpoint-out-port');
    if (
      !(nameEl instanceof HTMLInputElement) ||
      !(hostEl instanceof HTMLInputElement) ||
      !(portEl instanceof HTMLInputElement)
    ) {
      showToast('error', 'Outbound form not ready');
      return;
    }
    const name = nameEl.value.trim();
    const host = hostEl.value.trim();
    const portValue = portEl.value;
    if (!name || !host || !portValue) {
      showToast('error', 'Name, host, and port are required');
      return;
    }
    const body = {
      kind: 'mllp_out',
      name,
      pipeline_id: null,
      config: { host, port: Number(portValue) },
    };
    const response = await fetch(`${ROOT_PATH}/api/engine/endpoints`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Create failed: ${detail}`);
      return;
    }
    showToast('success', 'Outbound endpoint created');
    nameEl.value = '';
    hostEl.value = '';
    portEl.value = '';
    await refreshEndpoints();
  }

  async function sendTestMessage() {
    const targetSelect = document.getElementById('endpoint-send-target');
    const hostInput = document.getElementById('endpoint-send-host');
    const portInput = document.getElementById('endpoint-send-port');
    const messageInput = document.getElementById('endpoint-send-message');
    if (
      !(targetSelect instanceof HTMLSelectElement) ||
      !(hostInput instanceof HTMLInputElement) ||
      !(portInput instanceof HTMLInputElement) ||
      !(messageInput instanceof HTMLTextAreaElement)
    ) {
      showToast('error', 'Send form not ready');
      return;
    }
    const targetName = targetSelect.value;
    if (!targetName && (!hostInput.value || !portInput.value)) {
      showToast('error', 'Select a target or provide host and port');
      return;
    }
    if (!messageInput.value.trim()) {
      showToast('error', 'Message is required');
      return;
    }
    const payload = {
      target_name: targetName || null,
      host: targetName ? null : hostInput.value.trim(),
      port: targetName ? null : Number(portInput.value),
      message_b64: encodeBase64(messageInput.value),
    };
    const response = await fetch(`${ROOT_PATH}/api/engine/mllp/send`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      const detail = await extractError(response);
      showToast('error', `Send failed: ${detail}`);
      return;
    }
    const data = await response.json();
    const preview = data.ack_preview ? `ACK preview: ${data.ack_preview}` : 'ACK received';
    showToast('success', preview);
  }

  async function fetchPipeline(id) {
    const root = ROOT_PATH;
    const response = await fetch(`${root}/api/engine/pipelines/${id}`);
    if (!response.ok) {
      throw new Error(await extractError(response));
    }
    return response.json();
  }

  function openEditor(record) {
    PLS.currentId = record?.id ?? null;
    PLS.origYaml = record?.yaml ?? '';
    document.getElementById('pl-name').value = record?.name ?? '';
    document.getElementById('pl-desc').value = record?.description ?? '';
    document.getElementById('pl-yaml').value = record?.yaml ?? `version: 1
name: example
adapter:
  type: sequence
  config:
    messages:
      - { id: "m1", text: "hello" }
operators:
  - { type: echo }
sinks:
  - { type: memory, config: { label: "mem" } }`;
    setEditorStatus('');
    document.getElementById('pl-editor').style.display = '';
    document.getElementById('pl-diff-card').style.display = 'none';
  }

  async function editPipeline(id) {
    try {
      const record = await fetchPipeline(id);
      openEditor(record);
    } catch (err) {
      console.error(err);
      setPipelineStatus('Failed to open pipeline.');
      showToast('error', `Failed to open pipeline: ${err.message || err}`);
    }
  }

  async function savePipeline() {
    const root = ROOT_PATH;
    const payload = {
      id: PLS.currentId,
      name: document.getElementById('pl-name').value.trim(),
      description: document.getElementById('pl-desc').value.trim() || null,
      yaml: document.getElementById('pl-yaml').value,
    };
    try {
      const response = await fetch(root + '/api/engine/pipelines', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      document.getElementById('pl-editor').style.display = 'none';
      setPipelineStatus('Pipeline saved.');
      showToast('success', 'Pipeline saved');
      PLS.origYaml = payload.yaml || '';
      await loadPipelines();
    } catch (err) {
      console.error(err);
      const message = `Save failed: ${err.message || err}`;
      setEditorStatus(message);
      showToast('error', message);
    }
  }

  async function validatePipeline() {
    const root = ROOT_PATH;
    const yaml = document.getElementById('pl-yaml').value;
    try {
      const response = await fetch(root + '/api/engine/pipelines/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ yaml }),
      });
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      setEditorStatus('Valid ✓');
      showToast('success', 'Spec is valid');
      document.getElementById('pl-diff-card').style.display = 'none';
    } catch (err) {
      console.error(err);
      const message = `Invalid: ${err.message || err}`;
      setEditorStatus(message);
      showToast('error', message);
    }
  }

  async function runPipeline(id, persist) {
    const root = ROOT_PATH;
    try {
      const response = await fetch(`${root}/api/engine/pipelines/${id}/run`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ persist, max_messages: 2 }),
      });
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      const message = persist ? 'Run persisted.' : 'Dry run completed.';
      setPipelineStatus(message);
      showToast('success', message);
      await loadInsightsSummary();
      await loadPipelines();
    } catch (err) {
      console.error(err);
      const message = `Run failed: ${err.message || err}`;
      setPipelineStatus(message);
      showToast('error', message);
    }

    ctx.fillStyle = '#c33';
    ctx.fillRect(width - 140, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Errors', width - 124, 16);

    ctx.fillStyle = '#d8a31a';
    ctx.fillRect(width - 84, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Warnings', width - 68, 16);

    ctx.fillStyle = '#2a9d62';
    ctx.fillRect(width - 44, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Passed', width - 28, 16);
  }

  async function deletePipeline(id) {
    const root = ROOT_PATH;
    if (!confirm('Delete this pipeline?')) return;
    try {
      const response = await fetch(`${root}/api/engine/pipelines/${id}`, { method: 'DELETE' });
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      setPipelineStatus('Pipeline deleted.');
      showToast('success', 'Pipeline deleted');
      await loadPipelines();
    } catch (err) {
      console.error(err);
      const message = `Delete failed: ${err.message || err}`;
      setPipelineStatus(message);
      showToast('error', message);
    }
  }

  function handlePipelineAction(event) {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;
    const action = target.dataset.action;
    const id = Number(target.dataset.pipeline);
    if (!action || Number.isNaN(id)) return;
    if (action === 'edit') {
      withBusy(target, () => editPipeline(id));
    } else if (action === 'delete') {
      withBusy(target, () => deletePipeline(id));
    } else if (action === 'run-dry') {
      withBusy(target, () => runPipeline(id, false));
    } else if (action === 'run-persist') {
      withBusy(target, () => runPipeline(id, true));
    } else if (action === 'run-bg') {
      withBusy(target, () => enqueueBackgroundRun(id));
    }
  }

  function renderInsightsChart(summary) {
    const canvas = document.getElementById('insights-chart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const runs = (summary?.by_run || []).slice(-10);
    const labels = runs.map((run) => `#${run.run_id}`);
    const dataErrors = runs.map((run) => run.issues.error || 0);
    const dataWarnings = runs.map((run) => run.issues.warning || 0);
    const dataPassed = runs.map((run) => run.issues.passed || 0);
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    const padL = 48;
    const padR = 16;
    const padT = 10;
    const padB = 30;
    const plotW = width - padL - padR;
    const plotH = height - padT - padB;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + plotH);
    ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    const maxVal = Math.max(1, ...dataErrors, ...dataWarnings, ...dataPassed);
    const groups = runs.length || 1;
    const groupW = plotW / groups;
    const barGap = 4;
    const barsPerGroup = 3;
    const barW = Math.max(6, (groupW - (barsPerGroup + 1) * barGap) / barsPerGroup);
    const toY = (value) => padT + plotH - (value / maxVal) * plotH;

    function drawBars(values, index, fillStyle) {
      ctx.fillStyle = fillStyle;
      for (let i = 0; i < groups; i += 1) {
        const gx = padL + i * groupW;
        const x = gx + barGap * (index + 1) + barW * index;
        const y = toY(values[i] || 0);
        const h = plotH - (y - padT);
        ctx.fillRect(x, y, barW, h);
      }
    }

    drawBars(dataErrors, 0, '#c33');
    drawBars(dataWarnings, 1, '#d8a31a');
    drawBars(dataPassed, 2, '#2a9d62');

    ctx.fillStyle = '#bbb';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial';
    const ticks = 4;
    for (let t = 0; t <= ticks; t += 1) {
      const val = Math.round((t / ticks) * maxVal);
      const y = toY(val);
      ctx.fillText(String(val), 6, y + 4);
      ctx.strokeStyle = '#2a2a2a';
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(padL + plotW, y);
      ctx.stroke();
    }

    for (let i = 0; i < groups; i += 1) {
      const gx = padL + i * groupW;
      ctx.fillText(labels[i] || '', gx + groupW * 0.3, padT + plotH + 18);
    }

    ctx.fillStyle = '#c33';
    ctx.fillRect(width - 140, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Errors', width - 124, 16);

    ctx.fillStyle = '#d8a31a';
    ctx.fillRect(width - 84, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Warnings', width - 68, 16);

    ctx.fillStyle = '#2a9d62';
    ctx.fillRect(width - 44, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Passed', width - 28, 16);
  }

  async function deletePipeline(id) {
    const root = ROOT_PATH;
    if (!confirm('Delete this pipeline?')) return;
    try {
      const response = await fetch(`${root}/api/engine/pipelines/${id}`, { method: 'DELETE' });
      if (!response.ok) {
        throw new Error(await extractError(response));
      }
      setPipelineStatus('Pipeline deleted.');
      showToast('success', 'Pipeline deleted');
      await loadPipelines();
    } catch (err) {
      console.error(err);
      const message = `Delete failed: ${err.message || err}`;
      setPipelineStatus(message);
      showToast('error', message);
    }
  }

  function handlePipelineAction(event) {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;
    const action = target.dataset.action;
    const id = Number(target.dataset.pipeline);
    if (!action || Number.isNaN(id)) return;
    if (action === 'edit') {
      withBusy(target, () => editPipeline(id));
    } else if (action === 'delete') {
      withBusy(target, () => deletePipeline(id));
    } else if (action === 'run-dry') {
      withBusy(target, () => runPipeline(id, false));
    } else if (action === 'run-persist') {
      withBusy(target, () => runPipeline(id, true));
    } else if (action === 'run-bg') {
      withBusy(target, () => enqueueBackgroundRun(id));
    }
  }

  function renderInsightsChart(summary) {
    const canvas = document.getElementById('insights-chart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const runs = (summary?.by_run || []).slice(-10);
    const labels = runs.map((run) => `#${run.run_id}`);
    const dataErrors = runs.map((run) => run.issues.error || 0);
    const dataWarnings = runs.map((run) => run.issues.warning || 0);
    const dataPassed = runs.map((run) => run.issues.passed || 0);
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    const padL = 48;
    const padR = 16;
    const padT = 10;
    const padB = 30;
    const plotW = width - padL - padR;
    const plotH = height - padT - padB;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + plotH);
    ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    const maxVal = Math.max(1, ...dataErrors, ...dataWarnings, ...dataPassed);
    const groups = runs.length || 1;
    const groupW = plotW / groups;
    const barGap = 4;
    const barsPerGroup = 3;
    const barW = Math.max(6, (groupW - (barsPerGroup + 1) * barGap) / barsPerGroup);
    const toY = (value) => padT + plotH - (value / maxVal) * plotH;

    function drawBars(values, index, fillStyle) {
      ctx.fillStyle = fillStyle;
      for (let i = 0; i < groups; i += 1) {
        const gx = padL + i * groupW;
        const x = gx + barGap * (index + 1) + barW * index;
        const y = toY(values[i] || 0);
        const h = plotH - (y - padT);
        ctx.fillRect(x, y, barW, h);
      }
    }

    drawBars(dataErrors, 0, '#c33');
    drawBars(dataWarnings, 1, '#d8a31a');
    drawBars(dataPassed, 2, '#2a9d62');

    ctx.fillStyle = '#bbb';
    ctx.font = '12px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial';
    const ticks = 4;
    for (let t = 0; t <= ticks; t += 1) {
      const val = Math.round((t / ticks) * maxVal);
      const y = toY(val);
      ctx.fillText(String(val), 6, y + 4);
      ctx.strokeStyle = '#2a2a2a';
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(padL + plotW, y);
      ctx.stroke();
    }

    for (let i = 0; i < groups; i += 1) {
      const gx = padL + i * groupW;
      ctx.fillText(labels[i] || '', gx + groupW * 0.3, padT + plotH + 18);
    }

    ctx.fillStyle = '#c33';
    ctx.fillRect(width - 140, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Errors', width - 124, 16);

    ctx.fillStyle = '#d8a31a';
    ctx.fillRect(width - 84, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Warnings', width - 68, 16);

    ctx.fillStyle = '#2a9d62';
    ctx.fillRect(width - 44, 8, 10, 10);
    ctx.fillStyle = '#ddd';
    ctx.fillText('Passed', width - 28, 16);
  }

  window.addEventListener('load', () => {
    loadInsightsSummary();
    loadPipelines();
    refreshJobs();
    refreshEndpoints();
    document.getElementById('pl-new-btn')?.addEventListener('click', () => openEditor(null));
    document.getElementById('pl-save-btn')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => savePipeline());
    });
    document.getElementById('pl-cancel-btn')?.addEventListener('click', () => {
      document.getElementById('pl-editor').style.display = 'none';
      document.getElementById('pl-diff-card').style.display = 'none';
      PLS.currentId = null;
    });
    document.getElementById('pl-validate-btn')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => validatePipeline());
    });
    document.getElementById('pl-table')?.addEventListener('click', handlePipelineAction);
    document.getElementById('pl-sync-btn')?.addEventListener('click', () => {
      const name = document.getElementById('pl-name').value;
      const textarea = document.getElementById('pl-yaml');
      textarea.value = syncYamlName(textarea.value, name);
      showToast('info', 'Synced name into YAML');
      document.getElementById('pl-diff-card').style.display = 'none';
    });
    document.getElementById('pl-diff-btn')?.addEventListener('click', renderYamlDiff);
    document.getElementById('jobs-table')?.addEventListener('click', handleJobAction);
    document.getElementById('jobs-refresh')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => refreshJobs());
    });

    document.getElementById('endpoints-refresh')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => refreshEndpoints());
    });
    document.getElementById('endpoint-create-in')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => createInboundEndpoint());
    });
    document.getElementById('endpoint-create-out')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => createOutboundEndpoint());
    });
    document.getElementById('endpoint-send-btn')?.addEventListener('click', (event) => {
      const button = event.currentTarget;
      if (!(button instanceof HTMLButtonElement)) return;
      withBusy(button, () => sendTestMessage());
    });
    document.getElementById('endpoints-table')?.addEventListener('click', handleEndpointAction);
    document.getElementById('endpoint-send-target')?.addEventListener('change', (event) => {
      const select = event.currentTarget;
      if (!(select instanceof HTMLSelectElement)) return;
      if (select.value) {
        document.getElementById('endpoint-send-host').value = '';
        document.getElementById('endpoint-send-port').value = '';
      }
    });

    document.getElementById('assist-preview')?.addEventListener('click', async () => {
      const pipelineId = currentPipelineId();
      if (!pipelineId) {
        showToast('error', 'Open or select a pipeline first');
        return;
      }
      const input = document.getElementById('assist-lookback');
      const lookback = Number(input instanceof HTMLInputElement ? input.value : '14') || 14;
      try {
        const response = await fetch('/api/engine/assist/preview', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pipeline_id: pipelineId, lookback_days: lookback }),
        });
        if (!response.ok) {
          throw new Error(await extractError(response));
        }
        const data = await response.json();
        const allow = document.getElementById('assist-allowlist');
        const severity = document.getElementById('assist-severity');
        const draft = document.getElementById('assist-draft');
        if (allow) {
          const items = Array.isArray(data.allowlist) ? data.allowlist : [];
          allow.textContent = items.length ? items.map((item) => JSON.stringify(item)).join('\n') : '—';
        }
        if (severity) {
          const items = Array.isArray(data.severity_rules) ? data.severity_rules : [];
          severity.textContent = items.length ? items.map((item) => JSON.stringify(item)).join('\n') : '—';
        }
        if (draft) {
          draft.textContent = typeof data.draft_yaml === 'string' && data.draft_yaml.trim() ? data.draft_yaml : '—';
        }
        showToast('success', 'Assist suggestions ready');
      } catch (err) {
        console.error(err);
        showToast('error', err.message || String(err));
      }
    });

    document.getElementById('assist-insert')?.addEventListener('click', () => {
      const textarea = document.getElementById('pl-yaml');
      const draft = document.getElementById('assist-draft');
      if (!(textarea instanceof HTMLTextAreaElement) || !draft) {
        showToast('error', 'Nothing to insert');
        return;
      }
      const content = (draft.textContent || '').trim();
      if (!content) {
        showToast('error', 'Nothing to insert');
        return;
      }
      textarea.value = `${textarea.value.trimEnd()}\n\n${content}\n`;
      showToast('success', 'Draft suggestions inserted (commented). Review and save when ready.');
    });

    document.getElementById('assist-load-anoms')?.addEventListener('click', async () => {
      const pipelineId = currentPipelineId();
      if (!pipelineId) {
        showToast('error', 'Open or select a pipeline first');
        return;
      }
      const recentInput = document.getElementById('assist-recent');
      const baselineInput = document.getElementById('assist-baseline');
      const recent = Number(recentInput instanceof HTMLInputElement ? recentInput.value : '7') || 7;
      const baseline = Number(baselineInput instanceof HTMLInputElement ? baselineInput.value : '30') || 30;
      try {
        const response = await fetch(`/api/engine/assist/anomalies?pipeline_id=${pipelineId}&recent_days=${recent}&baseline_days=${baseline}`);
        if (!response.ok) {
          throw new Error(await extractError(response));
        }
        const data = await response.json();
        const tbody = document.querySelector('#assist-anoms-table tbody');
        if (tbody) {
          const items = Array.isArray(data.items) ? data.items : [];
          const rows = items.map((anomaly) => {
            const start = anomaly.window_start ? new Date(anomaly.window_start).toLocaleDateString() : '';
            const end = anomaly.window_end ? new Date(anomaly.window_end).toLocaleDateString() : '';
            const deviation = typeof anomaly.deviation === 'number' ? Math.abs(anomaly.deviation).toFixed(2) : '';
            const baselineVal = typeof anomaly.baseline === 'number' ? anomaly.baseline.toFixed(2) : '';
            return `<tr>
              <td>${escapeHtml(anomaly.code || '')}</td>
              <td>${escapeHtml(anomaly.segment || '')}</td>
              <td>${Number(anomaly.count) || 0}</td>
              <td>${baselineVal}</td>
              <td>${deviation}</td>
              <td>${escapeHtml(start)} → ${escapeHtml(end)}</td>
            </tr>`;
          }).join('');
          tbody.innerHTML = rows || '<tr><td colspan="6">No anomalies.</td></tr>';
        }
        showToast('success', 'Anomalies loaded');
      } catch (err) {
        console.error(err);
        showToast('error', err.message || String(err));
      }
    });
  });
</script>
{% endblock %}
