/*! Simplified HTMX-compatible runtime (v1.9.12) */
(function(window, document){
  "use strict";

  if (window.htmx && window.htmx.version === "1.9.12") {
    return;
  }

  var toArray = function(list){ return Array.prototype.slice.call(list || []); };
  var noop = function(){};

  var config = {
    timeout: 0,
    defaultSwapStyle: "innerHTML",
    includeIndicatorClass: "htmx-indicator",
    requestClass: "htmx-request",
    disableSelector: null
  };

  var loggerEnabled = false;
  var log = function(){
    if (loggerEnabled && console && console.log){
      console.log.apply(console, ["[htmx]"].concat(toArray(arguments)));
    }
  };

  var fireEvent = function(elt, name, detail){
    detail = detail ? Object.assign({}, detail) : {};
    detail.elt = elt;
    var event;
    try {
      event = new CustomEvent(name, { bubbles: true, cancelable: true, detail: detail });
    } catch (e) {
      event = document.createEvent("CustomEvent");
      event.initCustomEvent(name, true, true, detail);
    }
    if (loggerEnabled) log("event", name, elt);
    return elt.dispatchEvent(event);
  };

  var matches = function(elt, selector){
    if (!elt || !selector) return false;
    if (elt.matches) return elt.matches(selector);
    if (elt.msMatchesSelector) return elt.msMatchesSelector(selector);
    if (elt.webkitMatchesSelector) return elt.webkitMatchesSelector(selector);
    return false;
  };

  var closest = function(elt, selector){
    if (!elt || !selector) return null;
    if (elt.closest) return elt.closest(selector);
    while (elt){ if (matches(elt, selector)) return elt; elt = elt.parentElement; }
    return null;
  };

  var parseJSONish = function(text){
    if (!text) return null;
    try { return JSON.parse(text); } catch (err) {
      try { return Function("return (" + text + ")")(); } catch (err2) {
        log("failed to parse JSON", text, err2);
        return null;
      }
    }
  };

  var parseDuration = function(value){
    if (!value) return 0;
    if (typeof value === "number") return value;
    var trimmed = String(value).trim();
    if (/ms$/.test(trimmed)) return parseFloat(trimmed.replace(/ms$/, "")) || 0;
    if (/s$/.test(trimmed)) return (parseFloat(trimmed.replace(/s$/, "")) || 0) * 1000;
    if (/m$/.test(trimmed)) return (parseFloat(trimmed.replace(/m$/, "")) || 0) * 60000;
    var numeric = parseFloat(trimmed);
    return isNaN(numeric) ? 0 : numeric;
  };

  var getAttribute = function(elt, name){
    return elt && elt.getAttribute ? elt.getAttribute(name) : null;
  };

  var hasAttribute = function(elt, name){
    return elt && elt.hasAttribute ? elt.hasAttribute(name) : false;
  };

  var resolveTarget = function(source, descriptor){
    if (!descriptor) return null;
    if (descriptor === "this") return source;
    if (typeof descriptor !== "string") return descriptor;
    if (descriptor.indexOf("closest ") === 0){
      return closest(source, descriptor.slice(8).trim());
    }
    if (descriptor.indexOf("find ") === 0){
      return source.querySelector(descriptor.slice(5).trim());
    }
    return document.querySelector(descriptor);
  };

  var swapInner = function(target, html){
    target.innerHTML = html;
    return target.firstElementChild || target.firstChild || target;
  };

  var swapContent = function(target, html, style){
    if (!target) return null;
    style = style || config.defaultSwapStyle;
    if (style === "none") return null;
    if (style === "outerHTML"){
      var parent = target.parentNode;
      if (!parent) return null;
      var tpl = document.createElement("div");
      tpl.innerHTML = html;
      var node = tpl.firstElementChild;
      if (node){ parent.replaceChild(node, target); return node; }
      parent.removeChild(target);
      return null;
    }
    if (style === "beforebegin" || style === "afterbegin" || style === "beforeend" || style === "afterend"){
      target.insertAdjacentHTML(style, html);
      if (style === "beforebegin") return target.previousElementSibling;
      if (style === "afterbegin") return target.firstElementChild;
      if (style === "beforeend") return target.lastElementChild;
      if (style === "afterend") return target.nextElementSibling;
    }
    return swapInner(target, html);
  };

  var collectIncludeElements = function(source, includeSelector){
    if (!includeSelector) return [];
    return includeSelector.split(",").map(function(token){
      return resolveTarget(source, token.trim()) || document.querySelector(token.trim());
    }).filter(Boolean);
  };

  var appendValue = function(formData, name, value){
    if (value === undefined || value === null) value = "";
    if (value instanceof File || value instanceof Blob){
      formData.append(name, value);
    } else if (Array.isArray(value)){
      value.forEach(function(v){ formData.append(name, v); });
    } else {
      formData.append(name, value);
    }
  };

  var addElementValues = function(formData, elt){
    if (!elt) return;
    if (elt instanceof HTMLFormElement){
      new FormData(elt).forEach(function(value, key){ formData.append(key, value); });
      return;
    }
    if (elt.name || elt.id){
      var name = elt.name || elt.id;
      if (elt.type === "checkbox"){
        if (elt.checked) appendValue(formData, name, elt.value || "on");
      } else if (elt.type === "radio"){
        if (elt.checked) appendValue(formData, name, elt.value);
      } else if (elt.files){
        Array.prototype.forEach.call(elt.files, function(file){ appendValue(formData, name, file); });
      } else {
        appendValue(formData, name, elt.value);
      }
    }
    toArray(elt.querySelectorAll("input[name], select[name], textarea[name]")).forEach(function(control){
      addElementValues(formData, control);
    });
  };

  var applyParamsFilter = function(formData, filter){
    if (!filter || filter === "*") return formData;
    var allowed = Array.isArray(filter) ? filter : String(filter).split(",").map(function(t){ return t.trim(); });
    var clone = new FormData();
    formData.forEach(function(value, key){
      if (allowed.indexOf(key) !== -1) clone.append(key, value);
    });
    return clone;
  };

  var formDataToObject = function(formData){
    var obj = {};
    formData.forEach(function(value, key){
      if (obj.hasOwnProperty(key)){
        if (!Array.isArray(obj[key])) obj[key] = [obj[key]];
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    });
    return obj;
  };

  var mergeValues = function(formData, values){
    if (!values) return formData;
    Object.keys(values).forEach(function(key){ appendValue(formData, key, values[key]); });
    return formData;
  };

  var createFormDataFromValues = function(values){
    var data = new FormData();
    if (!values) return data;
    Object.keys(values).forEach(function(key){ appendValue(data, key, values[key]); });
    return data;
  };

  var indicatorOn = function(indicator){
    if (!indicator) return;
    indicator.classList.add(config.includeIndicatorClass);
    indicator.style.display = indicator.dataset.htmxOriginalDisplay || "";
  };

  var indicatorOff = function(indicator){
    if (!indicator) return;
    indicator.classList.remove(config.includeIndicatorClass);
    if (indicator.dataset.htmxOriginalDisplay !== undefined){
      indicator.style.display = indicator.dataset.htmxOriginalDisplay;
    }
  };

  var disableElements = function(elements, disabled){
    elements.forEach(function(el){
      if (!el) return;
      if (disabled){
        el.dataset.htmxDisabled = "1";
        if (el.disabled === undefined) el.setAttribute("disabled", "disabled"); else el.disabled = true;
      } else if (el.dataset.htmxDisabled){
        delete el.dataset.htmxDisabled;
        if (el.disabled === undefined) el.removeAttribute("disabled"); else el.disabled = false;
      }
    });
  };

  var currentRequests = new WeakMap();

  var processSwap = function(target, html, swapStyle){
    var newNode = swapContent(target, html, swapStyle);
    if (newNode) processNode(newNode);
    processNode(target);
  };

  var addUrlToHistory = function(url, replace){
    if (!url) return;
    try {
      if (replace) window.history.replaceState({}, "", url);
      else window.history.pushState({}, "", url);
    } catch (err){ log("history push failed", err); }
  };

  var performFetch = function(request){
    var source = request.source;
    var indicator = request.indicator;
    var disableList = request.disableList;
    indicatorOn(indicator);
    disableElements(disableList, true);
    source.classList.add(config.requestClass);

    var controller = config.timeout ? new AbortController() : null;
    if (controller) request.signal = controller.signal;

    currentRequests.set(source, controller);

    var fireSource = function(name, detail){ return fireEvent(source, name, detail); };
    var fireTarget = function(name, detail){ return request.target ? fireEvent(request.target, name, detail) : true; };
    var fireBoth = function(name, detail){
      var ok = true;
      if (request.target) ok = fireTarget(name, detail) !== false && ok;
      ok = fireSource(name, detail) !== false && ok;
      return ok;
    };

    var headers = request.headers || {};
    headers["HX-Request"] = "true";
    headers["X-Requested-With"] = "XMLHttpRequest";

    var fetchOptions = {
      method: request.method,
      headers: headers,
      credentials: "same-origin"
    };

    if (controller) fetchOptions.signal = controller.signal;

    if (request.body){
      if (request.body instanceof FormData){
        fetchOptions.body = request.body;
      } else if (typeof request.body === "string" || request.body instanceof Blob){
        fetchOptions.body = request.body;
      } else {
        fetchOptions.body = JSON.stringify(request.body);
        if (!fetchOptions.headers["Content-Type"]) fetchOptions.headers["Content-Type"] = "application/json";
      }
    }

    var proceed = fireSource("htmx:beforeRequest", { path: request.url, parameters: request.parameters, headers: headers });
    if (proceed === false){
      indicatorOff(indicator);
      disableElements(disableList, false);
      source.classList.remove(config.requestClass);
      currentRequests.delete(source);
      return;
    }

    var fetchPromise = fetch(request.url, fetchOptions)
      .then(function(response){
        var detail = { path: request.url, xhr: response, request: request };
        fireSource("htmx:afterRequest", detail);
        if (!response.ok){
          fireSource("htmx:responseError", detail);
          throw response;
        }
        return response.text().then(function(text){
          return { response: response, text: text };
        });
      })
      .then(function(payload){
        var response = payload.response;
        var text = payload.text;
        var swapTarget = request.target;
        if (!swapTarget || request.swapStyle === "none") return;
        var beforeOnLoad = fireBoth("htmx:beforeOnLoad", { target: swapTarget, xhr: response, request: request });
        if (beforeOnLoad === false) return;
        var before = fireBoth("htmx:beforeSwap", { target: swapTarget, xhr: response, request: request, detail: payload });
        if (before === false) return;
        processSwap(swapTarget, text, request.swapStyle);
        fireBoth("htmx:afterOnLoad", { target: swapTarget, xhr: response, request: request });
        fireBoth("htmx:afterSwap", { target: swapTarget, xhr: response, request: request });
        fireBoth("htmx:afterSettle", { target: swapTarget, xhr: response, request: request });
        if (request.pushUrl) addUrlToHistory(request.pushUrl, false);
        if (request.replaceUrl) addUrlToHistory(request.replaceUrl, true);
      })
      .catch(function(err){
        if (err && err.name === "AbortError"){
          fireSource("htmx:timeout", { request: request });
          return;
        }
        fireSource("htmx:sendError", { error: err, request: request });
      })
      .finally(function(){
        source.classList.remove(config.requestClass);
        indicatorOff(indicator);
        disableElements(disableList, false);
        currentRequests.delete(source);
      });

    if (controller && config.timeout){
      setTimeout(function(){ controller.abort(); }, config.timeout);
    }

    return fetchPromise;
  };

  var buildRequest = function(source, event, overrides){
    overrides = overrides || {};
    var url = overrides.url || getAttribute(source, "hx-get") || getAttribute(source, "hx-post") || getAttribute(source, "hx-put") || getAttribute(source, "hx-patch") || getAttribute(source, "hx-delete");
    if (!url) return null;

    var method = overrides.method;
    if (!method){
      if (hasAttribute(source, "hx-post")) method = "POST";
      else if (hasAttribute(source, "hx-put")) method = "PUT";
      else if (hasAttribute(source, "hx-patch")) method = "PATCH";
      else if (hasAttribute(source, "hx-delete")) method = "DELETE";
      else method = "GET";
    }

    var target = source;
    if (overrides.target){
      target = resolveTarget(source, overrides.target);
      if (!target && typeof overrides.target === "string"){ target = document.querySelector(overrides.target); }
      if (!target) target = source;
    } else {
      var targetAttr = getAttribute(source, "hx-target");
      if (targetAttr){ target = resolveTarget(source, targetAttr.trim()) || source; }
    }
    var swapStyle = overrides.swap || getAttribute(source, "hx-swap") || config.defaultSwapStyle;

    var confirmText = getAttribute(source, "hx-confirm");
    if (confirmText && !window.confirm(confirmText)) return null;

    var promptText = getAttribute(source, "hx-prompt");
    var promptValue = null;
    if (promptText){
      promptValue = window.prompt(promptText);
      if (promptValue === null) return null;
    }

    var indicator = null;
    var indicatorSelector = getAttribute(source, "hx-indicator");
    if (indicatorSelector) indicator = resolveTarget(source, indicatorSelector.trim()) || document.querySelector(indicatorSelector.trim());
    if (!indicator){ indicator = closest(source, "[data-htmx-indicator]") || null; }
    if (indicator){
      if (indicator.dataset.htmxOriginalDisplay === undefined){
        indicator.dataset.htmxOriginalDisplay = indicator.style.display;
      }
    }

    var disableList = [source];
    var disableAttr = getAttribute(source, "hx-disable");
    if (disableAttr){
      disableList = disableList.concat(disableAttr.split(",").map(function(token){
        return resolveTarget(source, token.trim()) || document.querySelector(token.trim());
      }).filter(Boolean));
    }

    var values = parseJSONish(getAttribute(source, "hx-vals"));
    if (promptValue !== null){ values = values || {}; values["prompt"] = promptValue; }

    var paramsFilter = getAttribute(source, "hx-params");
    var includeSelector = getAttribute(source, "hx-include");
    var includes = collectIncludeElements(source, includeSelector);

    var formData = new FormData();
    if (event && event.detail && event.detail.parameters){
      Object.keys(event.detail.parameters).forEach(function(key){ appendValue(formData, key, event.detail.parameters[key]); });
    }

    if (source instanceof HTMLFormElement){
      addElementValues(formData, source);
    } else if (source.name || source.id){
      addElementValues(formData, source);
    }

    includes.forEach(function(node){ addElementValues(formData, node); });

    formData = applyParamsFilter(formData, paramsFilter);
    formData = mergeValues(formData, values);

    var headers = parseJSONish(getAttribute(source, "hx-headers")) || {};

    var body = null;
    var parameters = formDataToObject(formData);
    if (method === "GET" || method === "DELETE"){
      var qs = new URLSearchParams();
      formData.forEach(function(value, key){ qs.append(key, value); });
      var query = qs.toString();
      if (query){
        var separator = url.indexOf("?") === -1 ? "?" : "&";
        url = url + separator + query;
      }
    } else {
      body = formData;
    }

    return {
      source: source,
      url: url,
      method: method,
      target: target,
      swapStyle: swapStyle,
      indicator: indicator,
      disableList: disableList,
      headers: headers,
      body: body,
      parameters: parameters,
      pushUrl: getAttribute(source, "hx-push-url"),
      replaceUrl: getAttribute(source, "hx-replace-url"),
      promptValue: promptValue
    };
  };

  var makeRequest = function(source, event, overrides){
    var request = buildRequest(source, event, overrides);
    if (!request) return;
    var configResult = fireEvent(source, "htmx:configRequest", { path: request.url, parameters: request.parameters, headers: request.headers });
    if (configResult === false) return;
    performFetch(request);
  };

  var parseTriggerDescriptor = function(text){
    var triggers = [];
    if (!text) return triggers;
    text.split(",").forEach(function(raw){
      var token = raw.trim();
      if (!token) return;
      var parts = token.split(/\s+/);
      var name = parts.shift();
      var descriptor = { event: name, once: false, delay: 0, changed: false, from: null, every: null };
      if (name === "every"){ var interval = parts.shift(); descriptor.event = "every"; descriptor.every = parseDuration(interval); }
      parts.forEach(function(part){
        if (!part) return;
        if (part === "once") descriptor.once = true;
        else if (part === "changed") descriptor.changed = true;
        else if (part.indexOf("delay:") === 0) descriptor.delay = parseDuration(part.split(":")[1]);
        else if (part.indexOf("from:") === 0) descriptor.from = part.split(":")[1];
      });
      triggers.push(descriptor);
    });
    return triggers;
  };

  var getDefaultTriggers = function(elt){
    if (elt instanceof HTMLFormElement) return [{ event: "submit", once: false, delay: 0 }];
    if (elt instanceof HTMLInputElement || elt instanceof HTMLSelectElement || elt instanceof HTMLTextAreaElement){
      if (elt.type === "submit" || elt.type === "button") return [{ event: "click", once: false, delay: 0 }];
      return [{ event: "change", once: false, delay: 0 }];
    }
    if (elt instanceof HTMLButtonElement) return [{ event: "click", once: false, delay: 0 }];
    return [{ event: "click", once: false, delay: 0 }];
  };

  var observedElements = new WeakMap();

  var bindTrigger = function(elt, trigger){
    var handler = function(event){
      if (event && (event.type === "click" || event.type === "submit")){
        if (event.preventDefault) event.preventDefault();
        if (event.type === "submit" && event.stopPropagation) event.stopPropagation();
      }
      if (trigger.changed){
        var prev = elt.dataset.htmxPrevValue;
        var current = elt.value;
        if (prev === current) return;
        elt.dataset.htmxPrevValue = current;
      }
      if (trigger.from){
        if (!event || !event.target) return;
        if (!closest(event.target, trigger.from)) return;
      }
      var execute = function(){ makeRequest(elt, event || {}); if (trigger.once) detach(); };
      if (trigger.delay) setTimeout(execute, trigger.delay); else execute();
    };

    var detach = function(){
      if (trigger.event === "every"){ var timer = observedElements.get(elt); if (timer){ clearInterval(timer); observedElements.delete(elt); } }
      else if (trigger.event === "revealed"){ var observer = observedElements.get(elt); if (observer){ observer.disconnect(); observedElements.delete(elt); } }
      else {
        var target = trigger.event === "submit" ? elt : (trigger.from ? document : elt);
        target.removeEventListener(trigger.event, handler, true);
      }
    };

    if (trigger.event === "load"){
      var run = function(){ handler({ type: "load", target: elt }); };
      if (trigger.delay) setTimeout(run, trigger.delay); else setTimeout(run, 0);
      if (trigger.once) observedElements.set(elt, { destroy: detach });
      return;
    }

    if (trigger.event === "every"){
      var interval = trigger.every || 0;
      if (!interval) return;
      var timerId = setInterval(function(){ handler({ type: "every", target: elt }); }, interval);
      observedElements.set(elt, timerId);
      return;
    }

    if (trigger.event === "revealed"){
      var observer = new IntersectionObserver(function(entries){
        entries.forEach(function(entry){
          if (entry.isIntersecting){
            handler({ type: "revealed", target: elt });
            if (trigger.once !== false) observer.unobserve(elt);
          }
        });
      });
      observer.observe(elt);
      observedElements.set(elt, observer);
      return;
    }

    var target = trigger.event === "submit" ? elt : (trigger.from ? document : elt);
    target.addEventListener(trigger.event, handler, true);
  };

  var bindElement = function(elt){
    if (elt.dataset.htmxBound) return;
    if (!(hasAttribute(elt, "hx-get") || hasAttribute(elt, "hx-post") || hasAttribute(elt, "hx-put") || hasAttribute(elt, "hx-patch") || hasAttribute(elt, "hx-delete"))) return;
    elt.dataset.htmxBound = "1";

    var triggerAttr = getAttribute(elt, "hx-trigger");
    var triggers = triggerAttr ? parseTriggerDescriptor(triggerAttr) : getDefaultTriggers(elt);
    triggers.forEach(function(trigger){ bindTrigger(elt, trigger); });
  };

  var processNode = function(node){
    if (!node || node.nodeType !== 1) return;
    bindElement(node);
    toArray(node.querySelectorAll("[hx-get], [hx-post], [hx-put], [hx-delete], [hx-patch]")).forEach(bindElement);
  };

  var observeMutations = function(){
    if (!window.MutationObserver) return;
    var observer = new MutationObserver(function(mutations){
      mutations.forEach(function(record){
        toArray(record.addedNodes).forEach(processNode);
      });
    });
    observer.observe(document.documentElement, { childList: true, subtree: true });
  };

  var htmx = {
    version: "1.9.12",
    config: config,
    logAll: function(){ loggerEnabled = true; },
    trigger: function(elt, name, detail){ if (!elt) return; fireEvent(elt, name, detail || {}); },
    ajax: function(method, url, options){
      options = options || {};
      var dummy = options.source || document.body;
      var request = buildRequest(dummy, null, {
        method: method,
        url: url,
        target: typeof options.target === "string" ? resolveTarget(dummy, options.target) || document.querySelector(options.target) : options.target,
        swap: options.swap || config.defaultSwapStyle
      });
      if (!request) return;
      if (options.headers) request.headers = Object.assign({}, request.headers || {}, options.headers);
      if (options.values){
        var extra = createFormDataFromValues(options.values);
        if (request.method === "GET" || request.method === "DELETE"){
          var qs = new URLSearchParams();
          extra.forEach(function(value, key){ qs.append(key, value); });
          var query = qs.toString();
          if (query){
            var sep = request.url.indexOf("?") === -1 ? "?" : "&";
            request.url = request.url + sep + query;
          }
        } else {
          if (!(request.body instanceof FormData)) request.body = new FormData();
          extra.forEach(function(value, key){ request.body.append(key, value); });
        }
        var extraObj = formDataToObject(extra);
        request.parameters = Object.assign({}, request.parameters || {}, extraObj);
      }
      if (options.target){
        request.target = typeof options.target === "string" ? resolveTarget(dummy, options.target) || document.querySelector(options.target) : options.target;
      }
      performFetch(request);
    },
    process: function(node){ processNode(node); }
  };

  window.htmx = htmx;

  document.addEventListener("DOMContentLoaded", function(){
    processNode(document.body);
    observeMutations();
    fireEvent(document.body, "htmx:load", {});
  });

})(window, document);
